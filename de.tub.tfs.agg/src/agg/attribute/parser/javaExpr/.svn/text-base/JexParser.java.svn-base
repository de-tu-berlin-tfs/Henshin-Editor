package agg.attribute.parser.javaExpr;


/* Generated By:JavaCC: Do not edit this line. JexParser.java */
/**
 * @version $Id: JexParser.java,v 1.13 2010/12/07 16:36:45 olga Exp $
 * @author $Author: olga $
 */
public class JexParser implements JexParserConstants {

	static final long serialVersionUID = 1L;

	protected static JJTJexParserState jjtree = new JJTJexParserState();

	/*
	 * Expression syntax follows.
	 */
	static final public void CompilationUnit() throws ParseError {
		Expression();
		jj_consume_token(0);
	}

	static final public void Expression() throws ParseError {
		jjtree.openIndefiniteNode(ASTExpression.jjtCreate("Expression"));
		ConditionalExpression();
		jjtree.closeIndefiniteNode();
		jjtree.updateCurrentNode(1);
	}

	static final public void ConditionalExpression() throws ParseError {
		ConditionalOrExpression();
		if (jj_mask_0[getToken(1).kind]) {
			jj_consume_token(24);
			Expression();
			jj_consume_token(25);
			jjtree.openDefiniteNode(ASTCondExpr.jjtCreate("CondExpr"));
			ConditionalExpression();
			jjtree.closeDefiniteNode(3);
			jjtree.updateCurrentNode(1);
		} else {
			jj_expLA1[0] = jj_gen;
		}
	}

	// static boolean[] jj_mask_0 = new boolean[51];
	static boolean[] jj_mask_0 = new boolean[53];
	static {
		jj_mask_0[24] = true;
	}

	static final public void ConditionalOrExpression() throws ParseError {
		ConditionalAndExpression();
		label_1: while (true) {
			if (jj_mask_1[getToken(1).kind]) {
				;
			} else {
				jj_expLA1[1] = jj_gen;
				break label_1;
			}
			jj_consume_token(26);
			jjtree.openDefiniteNode(ASTOrNode.jjtCreate("OrNode"));
			ConditionalAndExpression();
			jjtree.closeDefiniteNode(2);
			jjtree.updateCurrentNode(1);
		}
	}

	static boolean[] jj_mask_1 = new boolean[53]; // [51];
	static {
		jj_mask_1[26] = true;
	}

	static final public void ConditionalAndExpression() throws ParseError {
		InclusiveOrExpression();
		label_2: while (true) {
			if (jj_mask_2[getToken(1).kind]) {
				;
			} else {
				jj_expLA1[2] = jj_gen;
				break label_2;
			}
			jj_consume_token(27);
			jjtree.openDefiniteNode(ASTAndNode.jjtCreate("AndNode"));
			InclusiveOrExpression();
			jjtree.closeDefiniteNode(2);
			jjtree.updateCurrentNode(1);
		}
	}

	static boolean[] jj_mask_2 = new boolean[53]; // [51];
	static {
		jj_mask_2[27] = true;
	}

	static final public void InclusiveOrExpression() throws ParseError {
		ExclusiveOrExpression();
		label_3: while (true) {
			if (jj_mask_3[getToken(1).kind]) {
				;
			} else {
				jj_expLA1[3] = jj_gen;
				break label_3;
			}
			jj_consume_token(28);
			jjtree
					.openDefiniteNode(ASTBitwiseOrNode
							.jjtCreate("BitwiseOrNode"));
			ExclusiveOrExpression();
			jjtree.closeDefiniteNode(2);
			jjtree.updateCurrentNode(1);
		}
	}

	static boolean[] jj_mask_3 = new boolean[53]; // [51];
	static {
		jj_mask_3[28] = true;
	}

	static final public void ExclusiveOrExpression() throws ParseError {
		AndExpression();
		label_4: while (true) {
			if (jj_mask_4[getToken(1).kind]) {
				;
			} else {
				jj_expLA1[4] = jj_gen;
				break label_4;
			}
			jj_consume_token(29);
			jjtree.openDefiniteNode(ASTBitwiseXorNode
					.jjtCreate("BitwiseXorNode"));
			AndExpression();
			jjtree.closeDefiniteNode(2);
			jjtree.updateCurrentNode(1);
		}
	}

	static boolean[] jj_mask_4 = new boolean[53]; // [51];
	static {
		jj_mask_4[29] = true;
	}

	static final public void AndExpression() throws ParseError {
		EqualityExpression();
		label_5: while (true) {
			if (jj_mask_5[getToken(1).kind]) {
				;
			} else {
				jj_expLA1[5] = jj_gen;
				break label_5;
			}
			jj_consume_token(30);
			jjtree.openDefiniteNode(ASTBitwiseAndNode
					.jjtCreate("BitwiseAndNode"));
			EqualityExpression();
			jjtree.closeDefiniteNode(2);
			jjtree.updateCurrentNode(1);
		}
	}

	static boolean[] jj_mask_5 = new boolean[53]; // [51];
	static {
		jj_mask_5[30] = true;
	}

	static final public void EqualityExpression() throws ParseError {
		RelationalExpression();
		label_6: while (true) {
			if (jj_mask_6[getToken(1).kind]) {
				;
			} else {
				jj_expLA1[6] = jj_gen;
				break label_6;
			}
			if (jj_mask_8[getToken(1).kind]) {
				jj_consume_token(31);
				jjtree.openDefiniteNode(ASTEQNode.jjtCreate("EQNode"));
				RelationalExpression();
				jjtree.closeDefiniteNode(2);
				jjtree.updateCurrentNode(1);
			} else {
				jj_expLA1[8] = jj_gen;
				if (jj_mask_7[getToken(1).kind]) {
					jj_consume_token(32);
					jjtree.openDefiniteNode(ASTNENode.jjtCreate("NENode"));
					RelationalExpression();
					jjtree.closeDefiniteNode(2);
					jjtree.updateCurrentNode(1);
				} else {
					jj_expLA1[7] = jj_gen;
					jj_consume_token(-1);
					throw new ParseError();
				}
			}
		}
	}

	static boolean[] jj_mask_6 = new boolean[53]; // [51];
	static {
		jj_mask_6[31] = jj_mask_6[32] = true;
	}

	static boolean[] jj_mask_7 = new boolean[53]; // [51];
	static {
		jj_mask_7[32] = true;
	}

	static boolean[] jj_mask_8 = new boolean[53]; // [51];
	static {
		jj_mask_8[31] = true;
	}

	static final public void RelationalExpression() throws ParseError {
		AdditiveExpression();
		label_7: while (true) {
			if (jj_mask_9[getToken(1).kind]) {
				;
			} else {
				jj_expLA1[9] = jj_gen;
				break label_7;
			}
			if (jj_mask_13[getToken(1).kind]) {
				jj_consume_token(33);
				jjtree.openDefiniteNode(ASTLTNode.jjtCreate("LTNode"));
				AdditiveExpression();
				jjtree.closeDefiniteNode(2);
				jjtree.updateCurrentNode(1);
			} else {
				jj_expLA1[13] = jj_gen;
				if (jj_mask_12[getToken(1).kind]) {
					jj_consume_token(34);
					jjtree.openDefiniteNode(ASTGTNode.jjtCreate("GTNode"));
					AdditiveExpression();
					jjtree.closeDefiniteNode(2);
					jjtree.updateCurrentNode(1);
				} else {
					jj_expLA1[12] = jj_gen;
					if (jj_mask_11[getToken(1).kind]) {
						jj_consume_token(35);
						jjtree.openDefiniteNode(ASTLENode.jjtCreate("LENode"));
						AdditiveExpression();
						jjtree.closeDefiniteNode(2);
						jjtree.updateCurrentNode(1);
					} else {
						jj_expLA1[11] = jj_gen;
						if (jj_mask_10[getToken(1).kind]) {
							jj_consume_token(36);
							jjtree.openDefiniteNode(ASTGENode
									.jjtCreate("GENode"));
							AdditiveExpression();
							jjtree.closeDefiniteNode(2);
							jjtree.updateCurrentNode(1);
						} else {
							jj_expLA1[10] = jj_gen;
							jj_consume_token(-1);
							throw new ParseError();
						}
					}
				}
			}
		}
	}

	static boolean[] jj_mask_9 = new boolean[53]; // [51];
	static {
		jj_mask_9[33] = jj_mask_9[34] = jj_mask_9[35] = jj_mask_9[36] = true;
	}

	static boolean[] jj_mask_10 = new boolean[53]; // [51];
	static {
		jj_mask_10[36] = true;
	}

	static boolean[] jj_mask_11 = new boolean[53]; // [51];
	static {
		jj_mask_11[35] = true;
	}

	static boolean[] jj_mask_12 = new boolean[53]; // [51];
	static {
		jj_mask_12[34] = true;
	}

	static boolean[] jj_mask_13 = new boolean[53]; // [51];
	static {
		jj_mask_13[33] = true;
	}

	static final public void AdditiveExpression() throws ParseError {
		MultiplicativeExpression();
		label_8: while (true) {
			if (jj_mask_14[getToken(1).kind]) {
				;
			} else {
				jj_expLA1[14] = jj_gen;
				break label_8;
			}
			if (jj_mask_16[getToken(1).kind]) {
				jj_consume_token(37);
				jjtree.openDefiniteNode(ASTAddNode.jjtCreate("AddNode"));
				MultiplicativeExpression();
				jjtree.closeDefiniteNode(2);
				jjtree.updateCurrentNode(1);
			} else {
				jj_expLA1[16] = jj_gen;
				if (jj_mask_15[getToken(1).kind]) {
					jj_consume_token(38);
					jjtree.openDefiniteNode(ASTSubtractNode
							.jjtCreate("SubtractNode"));
					MultiplicativeExpression();
					jjtree.closeDefiniteNode(2);
					jjtree.updateCurrentNode(1);
				} else {
					jj_expLA1[15] = jj_gen;
					jj_consume_token(-1);
					throw new ParseError();
				}
			}
		}
	}

	static boolean[] jj_mask_14 = new boolean[53]; // [51];
	static {
		jj_mask_14[37] = jj_mask_14[38] = true;
	}

	static boolean[] jj_mask_15 = new boolean[53]; // [51];
	static {
		jj_mask_15[38] = true;
	}

	static boolean[] jj_mask_16 = new boolean[53]; // [51];
	static {
		jj_mask_16[37] = true;
	}

	static final public void MultiplicativeExpression() throws ParseError {
		UnaryExpression();
		label_9: while (true) {
			if (jj_mask_17[getToken(1).kind]) {
				;
			} else {
				jj_expLA1[17] = jj_gen;
				break label_9;
			}
			if (jj_mask_20[getToken(1).kind]) {
				jj_consume_token(39);
				jjtree.openDefiniteNode(ASTMulNode.jjtCreate("MulNode"));
				UnaryExpression();
				jjtree.closeDefiniteNode(2);
				jjtree.updateCurrentNode(1);
			} else {
				jj_expLA1[20] = jj_gen;
				if (jj_mask_19[getToken(1).kind]) {
					jj_consume_token(40);
					jjtree.openDefiniteNode(ASTDivNode.jjtCreate("DivNode"));
					UnaryExpression();
					jjtree.closeDefiniteNode(2);
					jjtree.updateCurrentNode(1);
				} else {
					jj_expLA1[19] = jj_gen;
					if (jj_mask_18[getToken(1).kind]) {
						jj_consume_token(41);
						jjtree
								.openDefiniteNode(ASTModNode
										.jjtCreate("ModNode"));
						UnaryExpression();
						jjtree.closeDefiniteNode(2);
						jjtree.updateCurrentNode(1);
					} else {
						jj_expLA1[18] = jj_gen;
						jj_consume_token(-1);
						throw new ParseError();
					}
				}
			}
		}
	}

	static boolean[] jj_mask_17 = new boolean[53]; // [51];
	static {
		jj_mask_17[39] = jj_mask_17[40] = jj_mask_17[41] = true;
	}

	static boolean[] jj_mask_18 = new boolean[53]; // [51];
	static {
		jj_mask_18[41] = true;
	}

	static boolean[] jj_mask_19 = new boolean[53]; // [51];
	static {
		jj_mask_19[40] = true;
	}

	static boolean[] jj_mask_20 = new boolean[53]; // [51];
	static {
		jj_mask_20[39] = true;
	}

	static final public void UnaryExpression() throws ParseError {
		if (jj_mask_23[getToken(1).kind]) {
			jj_consume_token(38);
			jjtree.openDefiniteNode(ASTNegNode.jjtCreate("NegNode"));
			UnaryExpression();
			jjtree.closeDefiniteNode(1);
			jjtree.updateCurrentNode(1);
		} else {
			jj_expLA1[23] = jj_gen;
			if (jj_mask_22[getToken(1).kind]) {
				jj_consume_token(37);
				UnaryExpression();
			} else {
				jj_expLA1[22] = jj_gen;
				if (jj_mask_21[getToken(1).kind]) {
					UnsignedUnaryExpression();
				} else {
					jj_expLA1[21] = jj_gen;
					jj_consume_token(-1);
					throw new ParseError();
				}
			}
		}
	}

	static boolean[] jj_mask_21 = new boolean[53]; // [51];
	static {
		jj_mask_21[INTEGER_LITERAL] = jj_mask_21[FLOATING_POINT_LITERAL] = jj_mask_21[CHARACTER_LITERAL] = jj_mask_21[STRING_LITERAL] = jj_mask_21[LPAREN] = jj_mask_21[DOLLAR] = jj_mask_21[42] = jj_mask_21[43] = jj_mask_21[44] = jj_mask_21[45] = jj_mask_21[46] = jj_mask_21[47] = jj_mask_21[IDENTIFIER] = true;
	}

	static boolean[] jj_mask_22 = new boolean[53]; // [51];
	static {
		jj_mask_22[37] = true;
	}

	static boolean[] jj_mask_23 = new boolean[53]; // [51];
	static {
		jj_mask_23[38] = true;
	}

	static final public void UnsignedUnaryExpression() throws ParseError {
		if (jj_mask_26[getToken(1).kind]) {
			jj_consume_token(42);
			jjtree.openDefiniteNode(ASTBitwiseComplNode
					.jjtCreate("BitwiseComplNode"));
			UnaryExpression();
			jjtree.closeDefiniteNode(1);
			jjtree.updateCurrentNode(1);
		} else {
			jj_expLA1[26] = jj_gen;
			if (jj_mask_25[getToken(1).kind]) {
				jj_consume_token(43);
				jjtree.openDefiniteNode(ASTNotNode.jjtCreate("NotNode"));
				UnaryExpression();
				jjtree.closeDefiniteNode(1);
				jjtree.updateCurrentNode(1);
			} else {
				jj_expLA1[25] = jj_gen;
				if (jj_mask_24[getToken(1).kind]) {
					PrimaryExpression();
				} else {
					jj_expLA1[24] = jj_gen;
					jj_consume_token(-1);
					throw new ParseError();
				}
			}
		}
	}

	static boolean[] jj_mask_24 = new boolean[53]; // [51];
	static {
		jj_mask_24[INTEGER_LITERAL] = jj_mask_24[FLOATING_POINT_LITERAL] = jj_mask_24[CHARACTER_LITERAL] = jj_mask_24[STRING_LITERAL] = jj_mask_24[LPAREN] = jj_mask_24[DOLLAR] = jj_mask_24[44] = jj_mask_24[45] = jj_mask_24[46] = jj_mask_24[47] = jj_mask_24[IDENTIFIER] = true;
	}

	static boolean[] jj_mask_25 = new boolean[53]; // [51];
	static {
		jj_mask_25[43] = true;
	}

	static boolean[] jj_mask_26 = new boolean[53]; // [51];
	static {
		jj_mask_26[42] = true;
	}

	static final public void PrimaryExpression() throws ParseError {
		if (jj_2_1(2147483647)) {
			ArrayAllocation();
		} else {
			if (jj_mask_28[getToken(1).kind]) {
				jjtree.openIndefiniteNode(ASTPrimaryExpression
						.jjtCreate("PrimaryExpression"));
				PrimaryPrefix();
				label_10: while (true) {
					if (jj_mask_27[getToken(1).kind]) {
						;
					} else {
						jj_expLA1[27] = jj_gen;
						break label_10;
					}
					PrimarySuffix();
				}
				jjtree.closeIndefiniteNode();
				jjtree.updateCurrentNode(1);
			} else {
				jj_expLA1[28] = jj_gen;
				jj_consume_token(-1);
				throw new ParseError();
			}
		}
	}

	static boolean[] jj_mask_27 = new boolean[53]; // [51];
	static {
		jj_mask_27[LBRACKET] = jj_mask_27[SEMICOLON] = jj_mask_27[DOT] = true;
	}

	static boolean[] jj_mask_28 = new boolean[53]; // [51];
	static {
		jj_mask_28[INTEGER_LITERAL] = jj_mask_28[FLOATING_POINT_LITERAL] 
		                            = jj_mask_28[CHARACTER_LITERAL] 
		                            = jj_mask_28[STRING_LITERAL] 
		                            = jj_mask_28[LPAREN] 
		                            = jj_mask_28[LBRACKET] 
		                            = jj_mask_28[DOLLAR] 
		                            = jj_mask_28[44] = jj_mask_28[45] 
		                            = jj_mask_28[46] = jj_mask_28[47] 
		                            = jj_mask_28[IDENTIFIER] 
//		                            = jj_mask_28[40] = jj_mask_28[52]        
		                            = true;
	}

	static final public void PrimaryPrefix() throws ParseError {
		if (jj_mask_33[getToken(1).kind]) {
			Literal();
		} else {
			jj_expLA1[33] = jj_gen;
			if (jj_mask_32[getToken(1).kind]) {
				Id();
			} else {
				jj_expLA1[32] = jj_gen;
				if (jj_mask_31[getToken(1).kind]) {
					jj_consume_token(DOLLAR);
					ClassName();
					jj_consume_token(DOLLAR);
				} else {
					jj_expLA1[31] = jj_gen;
					if (jj_mask_30[getToken(1).kind]) {
						jj_consume_token(LPAREN);
						Expression();
						jj_consume_token(RPAREN);
					} else {
						jj_expLA1[30] = jj_gen;
						if (jj_mask_29[getToken(1).kind]) {
							AllocationExpression();
						} else {
							jj_expLA1[29] = jj_gen;
							jj_consume_token(-1);
							throw new ParseError();
						}
					}
				}
			}
		}
	}

	static boolean[] jj_mask_29 = new boolean[53]; // [51];
	static {
		jj_mask_29[44] = true;
	}

	static boolean[] jj_mask_30 = new boolean[53]; // [51];
	static {
		jj_mask_30[LPAREN] = true;
	}

	static boolean[] jj_mask_31 = new boolean[53]; // [51];
	static {
		jj_mask_31[DOLLAR] = true;
	}

	static boolean[] jj_mask_32 = new boolean[53]; // [51];
	static {
		jj_mask_32[IDENTIFIER] = true;
	}

	static boolean[] jj_mask_33 = new boolean[53]; // [51];
	static {
		jj_mask_33[INTEGER_LITERAL] = jj_mask_33[FLOATING_POINT_LITERAL] = jj_mask_33[CHARACTER_LITERAL] = jj_mask_33[STRING_LITERAL] = jj_mask_33[45] = jj_mask_33[46] = jj_mask_33[47] = true;
	}

	static final public void PrimarySuffix() throws ParseError {
		if (jj_mask_36[getToken(1).kind]) {
			ArrayIndex();
		} else {
			jj_expLA1[36] = jj_gen;
			if (jj_mask_35[getToken(1).kind]) {
				Member();
			} else {
				jj_expLA1[35] = jj_gen;
				if (jj_mask_34[getToken(1).kind]) {
					Action();
				} else {
					jj_expLA1[34] = jj_gen;
					jj_consume_token(-1);
					throw new ParseError();
				}
			}
		}
	}

	static boolean[] jj_mask_34 = new boolean[53]; // [51];
	static {
		jj_mask_34[SEMICOLON] = true;
	}

	static boolean[] jj_mask_35 = new boolean[53]; // [51];
	static {
		jj_mask_35[DOT] = true;
	}

	static boolean[] jj_mask_36 = new boolean[53]; // [51];
	static {
		jj_mask_36[LBRACKET] = true;
	}

	static final public void ArrayIndex() throws ParseError {
		jjtree.openIndefiniteNode(ASTArrayIndex.jjtCreate("ArrayIndex"));
		jj_consume_token(LBRACKET);
		Expression();
		jj_consume_token(RBRACKET);
		jjtree.closeIndefiniteNode();
		jjtree.updateCurrentNode(1);
	}

	static final public void Action() throws ParseError {
		jjtree.openIndefiniteNode(ASTAction.jjtCreate("Action"));
		jj_consume_token(SEMICOLON);
		MemberName();
		ArgumentList();
		jjtree.closeIndefiniteNode();
		jjtree.updateCurrentNode(1);
	}

	static final public void Member() throws ParseError {
		jj_consume_token(DOT);
		if (jj_2_2(2147483647)) {
			jjtree.openIndefiniteNode(ASTMethod.jjtCreate("Method"));
			MemberName();
			ArgumentList();
			jjtree.closeIndefiniteNode();
			jjtree.updateCurrentNode(1);
		} else {
			if (jj_mask_37[getToken(1).kind]) {
				jjtree.openDefiniteNode(ASTField.jjtCreate("Field"));
				MemberName();
				jjtree.closeDefiniteNode(1);				
				jjtree.updateCurrentNode(1);
			} else {
				jj_expLA1[37] = jj_gen;
				jj_consume_token(-1);
				throw new ParseError();
			}
		}
	}

	static boolean[] jj_mask_37 = new boolean[53]; // [51];
	static {
		jj_mask_37[IDENTIFIER] = true;
	}

	static final public void ArgumentList() throws ParseError {
		jj_consume_token(LPAREN);
		if (jj_mask_39[getToken(1).kind]) {
			Expression();
			label_11: while (true) {
				if (jj_mask_38[getToken(1).kind]) {
					;
				} else {
					jj_expLA1[38] = jj_gen;
					break label_11;
				}
				jj_consume_token(COMMA);
				Expression();
			}
		} else {
			jj_expLA1[39] = jj_gen;
			;
		}
		jj_consume_token(RPAREN);
	}

	static boolean[] jj_mask_38 = new boolean[53]; // [51];
	static {
		jj_mask_38[COMMA] = true;
	}

	static boolean[] jj_mask_39 = new boolean[53]; // [51];
	static {
		jj_mask_39[INTEGER_LITERAL] = jj_mask_39[FLOATING_POINT_LITERAL] = jj_mask_39[CHARACTER_LITERAL] = jj_mask_39[STRING_LITERAL] = jj_mask_39[LPAREN] =
		// jj_mask_39[LBRACKET] =
		jj_mask_39[DOLLAR] = jj_mask_39[37] = jj_mask_39[38] = jj_mask_39[42] = jj_mask_39[43] = jj_mask_39[44] = jj_mask_39[45] = jj_mask_39[46] = jj_mask_39[47] = jj_mask_39[IDENTIFIER] = true;
	}

	static final public void DimensionList() throws ParseError {
		label_12: while (true) {
			if (jj_2_3(2147483647)) {
				jj_consume_token(LBRACKET);
				jjtree.openIndefiniteNode(ASTEmptyDimension
						.jjtCreate("EmptyDimension"));
				jj_consume_token(RBRACKET);
				jjtree.closeIndefiniteNode();
				jjtree.updateCurrentNode(1);
			} else {
				if (jj_mask_40[getToken(1).kind]) {
					jj_consume_token(LBRACKET);
					Expression();
					jj_consume_token(RBRACKET);
				} else {
					jj_expLA1[40] = jj_gen;
					jj_consume_token(-1);
					throw new ParseError();
				}
			}
			if (jj_mask_41[getToken(1).kind]) {
				;
			} else {
				jj_expLA1[41] = jj_gen;
				break label_12;
			}
		}
	}

	static boolean[] jj_mask_40 = new boolean[53]; // [51];
	static {
		jj_mask_40[LBRACKET] = true;
	}

	static boolean[] jj_mask_41 = new boolean[53]; // [51];
	static {
		jj_mask_41[LBRACKET] = true;
	}

	static final public void AllocationExpression() throws ParseError {
		jjtree.openIndefiniteNode(ASTAllocationExpression
				.jjtCreate("AllocationExpression"));
		jj_consume_token(44);
		FullClassName();
		ArgumentList();
		jjtree.closeIndefiniteNode();
		jjtree.updateCurrentNode(1);
	}

	static final public void ArrayAllocation() throws ParseError {
		jjtree.openIndefiniteNode(ASTArrayAllocation
				.jjtCreate("ArrayAllocation"));
		jj_consume_token(44);
		FullClassName();
		DimensionList();
		jjtree.closeIndefiniteNode();
		jjtree.updateCurrentNode(1);
	}

	static final public void MemberName() throws ParseError {
		Token t;
		jjtree.openIndefiniteNode(ASTMemberName.jjtCreate("MemberName"));
		t = jj_consume_token(IDENTIFIER);
		try {
			ASTMemberName jjtThis = (ASTMemberName) jjtree.currentNode();
			jjtThis.name = t.image;
		} finally {
			jjtree.closeIndefiniteNode();
			jjtree.updateCurrentNode(1);
		}
	}

	static final public void FullClassName() throws ParseError {
		if (jj_mask_43[getToken(1).kind]) {
			ClassName();
		} else {
			jj_expLA1[43] = jj_gen;
			if (jj_mask_42[getToken(1).kind]) {
				jj_consume_token(DOLLAR);
				ClassName();
				jj_consume_token(DOLLAR);
			} else {
				jj_expLA1[42] = jj_gen;
				jj_consume_token(-1);
				throw new ParseError();
			}
		}
	}

	static boolean[] jj_mask_42 = new boolean[53]; // [51];
	static {
		jj_mask_42[DOLLAR] = true;
	}

	static boolean[] jj_mask_43 = new boolean[53]; // [51];
	static {
		jj_mask_43[IDENTIFIER] = true;
	}

	static final public void ClassName() throws ParseError {
		Token t;
		jjtree.openIndefiniteNode(ASTClassName.jjtCreate("ClassName"));
		t = jj_consume_token(IDENTIFIER);
		try {
			ASTClassName jjtThis = (ASTClassName) jjtree.currentNode();
			jjtThis.name = t.image;
		} finally {
		}
		label_13: while (true) {
			if (jj_mask_44[getToken(1).kind]) {
				;
			} else {
				jj_expLA1[44] = jj_gen;
				break label_13;
			}
			jj_consume_token(DOT);
			t = jj_consume_token(IDENTIFIER);
			try {
				ASTClassName jjtThis = (ASTClassName) jjtree.currentNode();
				jjtThis.name += "." + t.image;
			} finally {
			}
		}
		jjtree.closeIndefiniteNode();
		jjtree.updateCurrentNode(1);
	}

	static boolean[] jj_mask_44 = new boolean[53]; // [51];
	static {
		jj_mask_44[DOT] = true;
	}

	static final public void Id() throws ParseError {
		Token t;
		jjtree.openIndefiniteNode(ASTId.jjtCreate("Id"));
		t = jj_consume_token(IDENTIFIER);
		try {
			ASTId jjtThis = (ASTId) jjtree.currentNode();
			jjtThis.name = t.image;
		} finally {
			jjtree.closeIndefiniteNode();
			jjtree.updateCurrentNode(1);
		}
	}

	static final public void Literal() throws ParseError {
		Token t;
		if (jj_mask_50[getToken(1).kind]) {
			jjtree
					.openIndefiniteNode(ASTIntConstNode
							.jjtCreate("IntConstNode"));
			t = jj_consume_token(INTEGER_LITERAL);
			try {
				ASTIntConstNode jjtThis = (ASTIntConstNode) jjtree
						.currentNode();
				jjtThis.val = Integer.decode(t.image).intValue();
			} finally {
				jjtree.closeIndefiniteNode();
				jjtree.updateCurrentNode(1);
			}
		} else {
			jj_expLA1[50] = jj_gen;
			if (jj_mask_49[getToken(1).kind]) {
				jjtree.openIndefiniteNode(ASTFloatConstNode
						.jjtCreate("FloatConstNode"));
				t = jj_consume_token(FLOATING_POINT_LITERAL);
				try {
					ASTFloatConstNode jjtThis = (ASTFloatConstNode) jjtree
							.currentNode();
					jjtThis.val = Double.valueOf(t.image).doubleValue();
				} finally {
					jjtree.closeIndefiniteNode();
					jjtree.updateCurrentNode(1);
				}
			} else {
				jj_expLA1[49] = jj_gen;
				if (jj_mask_48[getToken(1).kind]) {
					jjtree.openIndefiniteNode(ASTCharConstNode
							.jjtCreate("CharConstNode"));
					t = jj_consume_token(CHARACTER_LITERAL);
					try {
						ASTCharConstNode jjtThis = (ASTCharConstNode) jjtree
								.currentNode();
						jjtThis.val = t.image.charAt(1);
					} finally {
						jjtree.closeIndefiniteNode();
						jjtree.updateCurrentNode(1);
					}
				} else {
					jj_expLA1[48] = jj_gen;
					if (jj_mask_47[getToken(1).kind]) {
						jjtree.openIndefiniteNode(ASTStringConstNode
								.jjtCreate("StringConstNode"));
						t = jj_consume_token(STRING_LITERAL);
						try {
							ASTStringConstNode jjtThis = (ASTStringConstNode) jjtree
									.currentNode();
							jjtThis.val = t.image;
						} finally {
							jjtree.closeIndefiniteNode();
							jjtree.updateCurrentNode(1);
						}
					} else {
						jj_expLA1[47] = jj_gen;
						if (jj_mask_46[getToken(1).kind]) {
							BooleanLiteral();
						} else {
							jj_expLA1[46] = jj_gen;
							if (jj_mask_45[getToken(1).kind]) {
								NullLiteral();
							} else {
								jj_expLA1[45] = jj_gen;
								jj_consume_token(-1);
								throw new ParseError();
							}
						}
					}
				}
			}
		}
	}

	static boolean[] jj_mask_45 = new boolean[53]; // [51];
	static {
		jj_mask_45[47] = true;
	}

	static boolean[] jj_mask_46 = new boolean[53]; // [51];
	static {
		jj_mask_46[45] = jj_mask_46[46] = true;
	}

	static boolean[] jj_mask_47 = new boolean[53]; // [51];
	static {
		jj_mask_47[STRING_LITERAL] = true;
	}

	static boolean[] jj_mask_48 = new boolean[53]; // [51];
	static {
		jj_mask_48[CHARACTER_LITERAL] = true;
	}

	static boolean[] jj_mask_49 = new boolean[53]; // [51];
	static {
		jj_mask_49[FLOATING_POINT_LITERAL] = true;
	}

	static boolean[] jj_mask_50 = new boolean[53]; // [51];
	static {
		jj_mask_50[INTEGER_LITERAL] = true;
	}

	static final public void BooleanLiteral() throws ParseError {
		if (jj_mask_52[getToken(1).kind]) {
			jjtree.openIndefiniteNode(ASTTrueNode.jjtCreate("TrueNode"));
			jj_consume_token(45);
			jjtree.closeIndefiniteNode();
			jjtree.updateCurrentNode(1);
		} else {
			jj_expLA1[52] = jj_gen;
			if (jj_mask_51[getToken(1).kind]) {
				jjtree.openIndefiniteNode(ASTFalseNode.jjtCreate("FalseNode"));
				jj_consume_token(46);
				jjtree.closeIndefiniteNode();
				jjtree.updateCurrentNode(1);
			} else {
				jj_expLA1[51] = jj_gen;
				jj_consume_token(-1);
				throw new ParseError();
			}
		}
	}

	static boolean[] jj_mask_51 = new boolean[53]; // [51];
	static {
		jj_mask_51[46] = true;
	}

	static boolean[] jj_mask_52 = new boolean[53]; // [51];
	static {
		jj_mask_52[45] = true;
	}

	static final public void NullLiteral() throws ParseError {
		jjtree.openIndefiniteNode(ASTNullLiteral.jjtCreate("NullLiteral"));
		jj_consume_token(47);
		jjtree.closeIndefiniteNode();
		jjtree.updateCurrentNode(1);
	}

	static final private boolean jj_2_1(int xla) throws ParseError {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_1();
		jj_save(0, xla);
		return retval;
	}

	static final private boolean jj_2_2(int xla) throws ParseError {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_2();
		jj_save(1, xla);
		return retval;
	}

	static final private boolean jj_2_3(int xla) throws ParseError {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_3();
		jj_save(2, xla);
		return retval;
	}

	static final private boolean jj_3_1() throws ParseError {
		if (jj_scan_token(44))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_3R_14())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(LBRACKET))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	static final private boolean jj_3_2() throws ParseError {
		if (jj_3R_15())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(LPAREN))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	static final private boolean jj_3_3() throws ParseError {
		if (jj_scan_token(LBRACKET))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(RBRACKET))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	static final private boolean jj_3R_14() throws ParseError {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_16()) {
			jj_scanpos = xsp;
			if (jj_3R_17())
				return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
		} else if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	static final private boolean jj_3R_15() throws ParseError {
		if (jj_scan_token(IDENTIFIER))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	static final private boolean jj_3R_16() throws ParseError {
		if (jj_3R_18())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	static final private boolean jj_3R_17() throws ParseError {
		if (jj_scan_token(DOLLAR))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_3R_18())
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(DOLLAR))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	static final private boolean jj_3R_18() throws ParseError {
		if (jj_scan_token(IDENTIFIER))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_19()) {
				jj_scanpos = xsp;
				break;
			}
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
		}
		return false;
	}

	static final private boolean jj_3R_19() throws ParseError {
		if (jj_scan_token(DOT))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		if (jj_scan_token(IDENTIFIER))
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		return false;
	}

	static private boolean jj_initialized_once = false;

	static public JexParserTokenManager token_source;

	static public Token token;

	static private Token jj_scanpos, jj_lastpos;

	static private int jj_la;

	static public boolean lookingAhead = false;

//	static private boolean jj_semLA;

	static private JexParser jj_me;

	static private int jj_gen;

	static private int[] jj_expLA1 = new int[53];

	static private JJJexParserCalls[] jj_2_rtns = new JJJexParserCalls[3];

	static private boolean jj_rescan = false;

	public JexParser(java.io.InputStream stream) {
		if (jj_initialized_once) {
			System.out
					.println("ERROR: Second call to constructor of static parser.  You must");
			System.out
					.println("       either use ReInit() or set the JavaCC option STATIC to false");
			System.out.println("       during parser generation.");
			throw new Error();
		}
		jj_initialized_once = true;
		ASCII_CharStream input_stream = new ASCII_CharStream(stream, 1, 1);
		token_source = new JexParserTokenManager(input_stream);
		token = new Token();
		jj_me = this;
		jj_gen = 0;
		for (int i = 0; i < 53; i++)
			jj_expLA1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJJexParserCalls();
	}

	static public void ReInit(java.io.InputStream stream) {
		ASCII_CharStream input_stream = new ASCII_CharStream(stream, 1, 1);
		JexParserTokenManager.ReInit(input_stream);
		token = new Token();
		jj_gen = 0;
		for (int i = 0; i < 53; i++)
			jj_expLA1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJJexParserCalls();
	}

	public JexParser(JexParserTokenManager tm) {
		if (jj_initialized_once) {
			System.out
					.println("ERROR: Second call to constructor of static parser.  You must");
			System.out
					.println("       either use ReInit() or set the JavaCC option STATIC to false");
			System.out.println("       during parser generation.");
			throw new Error();
		}
		jj_initialized_once = true;
		token_source = tm;
		token = new Token();
		jj_me = this;
		jj_gen = 0;
		for (int i = 0; i < 53; i++)
			jj_expLA1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJJexParserCalls();
	}

	public void ReInit(JexParserTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_gen = 0;
		for (int i = 0; i < 53; i++)
			jj_expLA1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJJexParserCalls();
	}

	static final private Token jj_consume_token(int kind) throws ParseError {
		if (token.next != null)
			token = token.next;
		else
			token = token.next = JexParserTokenManager.getNextToken();
		if (token.kind == kind) {
			jj_gen++;
			return token;
		}
//		 System.out.println("JexParser.jj_consume_token:: "+token.image+"   "+token.kind);
//		 Thread.dumpStack();
		
		jj_token_error_setup(token, kind);
		throw new ParseError();
	}

	static final private boolean jj_scan_token(int kind) throws ParseError {
		if (jj_scanpos == jj_lastpos) {
			jj_la--;
			if (jj_scanpos.next == null) {
				jj_lastpos = jj_scanpos = jj_scanpos.next = JexParserTokenManager
						.getNextToken();
			} else {
				jj_lastpos = jj_scanpos = jj_scanpos.next;
			}
		} else {
			jj_scanpos = jj_scanpos.next;
		}
		if (jj_rescan) {
			int i = 1;
			Token tok = token;
			while (tok != null && tok != jj_scanpos) {
				i++;
				tok = tok.next;
			}
			if (tok != null)
				jj_add_error_token(kind, i);
		}
		return (jj_scanpos.kind != kind);
	}

	static final public Token getNextToken() throws ParseError {
		if (token.next != null)
			token = token.next;
		else
			token = token.next = JexParserTokenManager.getNextToken();
		jj_gen++;
		return token;
	}

	static final public Token getToken(int index) throws ParseError {
		Token t = lookingAhead ? jj_scanpos : token;
		for (int i = 0; i < index; i++) {
//			System.out.println(i+" Token t: "+t.kind+" "+t.image);
			if (t.next != null) {
				t = t.next;
//				System.out.println(i+" next Token t: "+t.kind+" "+t.image);
			}
			else
				t = t.next = JexParserTokenManager.getNextToken();
		}
		return t;
	}

	static final String jj_add_escapes(String str) {
		String retval = "";
		char ch;
		for (int i = 0; i < str.length(); i++) {
			ch = str.charAt(i);
			if (ch == '\b') {
				retval += "\\b";
			} else if (ch == '\t') {
				retval += "\\t";
			} else if (ch == '\n') {
				retval += "\\n";
			} else if (ch == '\f') {
				retval += "\\f";
			} else if (ch == '\r') {
				retval += "\\r";
			} else if (ch == '\"') {
				retval += "\\\"";
			} else if (ch == '\'') {
				retval += "\\\'";
			} else if (ch == '\\') {
				retval += "\\\\";
			} else if (ch < 0x20 || ch > 0x7e) {
				String s = "0000" + Integer.toString(ch, 16);
				retval += "\\u" + s.substring(s.length() - 4, s.length());
			} else {
				retval += ch;
			}
		}
		return retval;
	}

	static protected int error_line;

	static protected int error_column;

	static protected String error_string;

	static protected String[] expected_tokens;

	protected void token_error() {
		System.out.println("");		
		System.out.println("Parse error at line " + error_line + ", column "
				+ error_column + ".  Encountered:");
		System.out.println("    \"" + jj_add_escapes(error_string) + "\"");
		System.out.println("");
		if (expected_tokens.length == 1) {
			System.out.println("Was expecting:");
		} else {
			System.out.println("Was expecting one of:");
		}
		for (int i = 0; i < expected_tokens.length; i++) {
			System.out.println("    " + expected_tokens[i]);
		}
		System.out.println("");
	}

	static private java.util.Vector<String> jj_errortokens = new java.util.Vector<String>();

	static private int[] jj_lasttokens = new int[100];

	static private int jj_endpos, jj_maxsize;

	static private void jj_add_error_token(int kind, int pos) {
		if (pos >= 100)
			return;
		if (pos == jj_endpos + 1) {
			jj_lasttokens[jj_endpos++] = kind;
		} else if (jj_endpos != 0) {
			if (jj_endpos > jj_maxsize)
				jj_maxsize = jj_endpos;
			String buf = "";
			for (int i = 0; i < jj_endpos; i++) {
				buf += tokenImage[jj_lasttokens[i]] + " ";
			}
			if (jj_lasttokens[jj_endpos - 1] != 0)
				buf += "...";
			boolean exists = false;
			for (java.util.Enumeration<String> en = jj_errortokens.elements(); en
					.hasMoreElements();) {
				if (buf.equals(en.nextElement())) {
					exists = true;
				}
			}
			if (!exists)
				jj_errortokens.addElement(buf);
			if (pos != 0)
				jj_lasttokens[(jj_endpos = pos) - 1] = kind;
		}
	}

	static final private void jj_token_error_setup(Token current, int kind)
			throws ParseError {
		jj_errortokens.removeAllElements();
		boolean[] la1tokens = new boolean[53]; // 51
		boolean[] mask = null;
		for (int i = 0; i < 53; i++) { // 51
			la1tokens[i] = false;
		}
		if (kind >= 0)
			la1tokens[kind] = true;
		for (int i = 0; i < 53; i++) {
			if (jj_expLA1[i] == jj_gen) {
				switch (i) {
				case 0:
					mask = jj_mask_0;
					break;
				case 1:
					mask = jj_mask_1;
					break;
				case 2:
					mask = jj_mask_2;
					break;
				case 3:
					mask = jj_mask_3;
					break;
				case 4:
					mask = jj_mask_4;
					break;
				case 5:
					mask = jj_mask_5;
					break;
				case 6:
					mask = jj_mask_6;
					break;
				case 7:
					mask = jj_mask_7;
					break;
				case 8:
					mask = jj_mask_8;
					break;
				case 9:
					mask = jj_mask_9;
					break;
				case 10:
					mask = jj_mask_10;
					break;
				case 11:
					mask = jj_mask_11;
					break;
				case 12:
					mask = jj_mask_12;
					break;
				case 13:
					mask = jj_mask_13;
					break;
				case 14:
					mask = jj_mask_14;
					break;
				case 15:
					mask = jj_mask_15;
					break;
				case 16:
					mask = jj_mask_16;
					break;
				case 17:
					mask = jj_mask_17;
					break;
				case 18:
					mask = jj_mask_18;
					break;
				case 19:
					mask = jj_mask_19;
					break;
				case 20:
					mask = jj_mask_20;
					break;
				case 21:
					mask = jj_mask_21;
					break;
				case 22:
					mask = jj_mask_22;
					break;
				case 23:
					mask = jj_mask_23;
					break;
				case 24:
					mask = jj_mask_24;
					break;
				case 25:
					mask = jj_mask_25;
					break;
				case 26:
					mask = jj_mask_26;
					break;
				case 27:
					mask = jj_mask_27;
					break;
				case 28:
					mask = jj_mask_28;
					break;
				case 29:
					mask = jj_mask_29;
					break;
				case 30:
					mask = jj_mask_30;
					break;
				case 31:
					mask = jj_mask_31;
					break;
				case 32:
					mask = jj_mask_32;
					break;
				case 33:
					mask = jj_mask_33;
					break;
				case 34:
					mask = jj_mask_34;
					break;
				case 35:
					mask = jj_mask_35;
					break;
				case 36:
					mask = jj_mask_36;
					break;
				case 37:
					mask = jj_mask_37;
					break;
				case 38:
					mask = jj_mask_38;
					break;
				case 39:
					mask = jj_mask_39;
					break;
				case 40:
					mask = jj_mask_40;
					break;
				case 41:
					mask = jj_mask_41;
					break;
				case 42:
					mask = jj_mask_42;
					break;
				case 43:
					mask = jj_mask_43;
					break;
				case 44:
					mask = jj_mask_44;
					break;
				case 45:
					mask = jj_mask_45;
					break;
				case 46:
					mask = jj_mask_46;
					break;
				case 47:
					mask = jj_mask_47;
					break;
				case 48:
					mask = jj_mask_48;
					break;
				case 49:
					mask = jj_mask_49;
					break;
				case 50:
					mask = jj_mask_50;
					break;
				case 51:
					mask = jj_mask_51;
					break;
				case 52:
					mask = jj_mask_52;
					break;
				}
				if (mask != null) {
					for (int j = 0; j < 53; j++) { // 51
						if (mask[j])
							la1tokens[j] = true;
					}
				}
			}
		}
		if (la1tokens[0]) {
			jj_errortokens.addElement(tokenImage[0] + " ");
		}
		for (int i = 1; i < 53; i++) { // 51
			if (la1tokens[i]) {
				jj_errortokens.addElement(tokenImage[i] + " ");
			}
		}
		jj_endpos = 0;
		jj_maxsize = 1;
		jj_rescan_token();
		jj_add_error_token(0, 0);
		expected_tokens = new String[jj_errortokens.size()];
		for (int i = 0; i < jj_errortokens.size(); i++) {
			expected_tokens[i] = jj_errortokens.elementAt(i);
		}
		error_line = current.beginLine;
		error_column = current.beginColumn;
		error_string = "";
		Token tok = current;
		for (int i = 0; i < jj_maxsize; i++) {
			if (tok.kind == 0) {
				error_string += " " + tokenImage[0];
				break;
			}
			error_string += " " + tok.image;
			tok = tok.next;
		}
		
		error_string = error_string.substring(1);
		
		if (!error_string.equals("(")) 
			jj_me.token_error();
	}

	static final public void enable_tracing() {
	}

	static final public void disable_tracing() {
	}

	static private void jj_rescan_token() throws ParseError {
		jj_rescan = true;
		for (int i = 0; i < 3; i++) {
			JJJexParserCalls p = jj_2_rtns[i];
			do {
				if (p.gen > jj_gen) {
					jj_la = p.arg;
					jj_lastpos = jj_scanpos = p.first;
					switch (i) {
					case 0:
						jj_3_1();
						break;
					case 1:
						jj_3_2();
						break;
					case 2:
						jj_3_3();
						break;
					}
				}
				p = p.next;
			} while (p != null);
		}
		jj_rescan = false;
	}

	static private void jj_save(int index, int xla) {
		JJJexParserCalls p = jj_2_rtns[index];
		while (p.gen > jj_gen) {
			if (p.next == null) {
				p = p.next = new JJJexParserCalls();
				break;
			}
			p = p.next;
		}
		p.gen = jj_gen + xla - jj_la;
		p.first = token;
		p.arg = xla;
	}

}

final class JJTJexParserState {
	/*
	 * JJTree builds the AST bottom up. It constructs nodes and places them on a
	 * stack. When all the children have been assembled, they are added to their
	 * parent and popped from the stack.
	 */
	private JJTJexParserNodeStack nodes;

	/*
	 * The current node is kept on the top of this stack so that user actions
	 * can always refer to it.
	 */
	private java.util.Stack<Node> current_nodes;

	/*
	 * We keep track of whether a node was actually created. Definite and
	 * indefinite nodes always are, but GT nodes are only closed and pushed on
	 * the stack if their conditions are true.
	 */
	private boolean node_created;

	JJTJexParserState() {
		this.nodes = new JJTJexParserNodeStack();
		this.current_nodes = new java.util.Stack<Node>();
	}

	/* Determine whether the current node was actually closed and pushed */
	boolean nodeCreated() {
		return this.node_created;
	}

	/*
	 * Called when the current node has been completely finished with. Makes a
	 * new node the current node.
	 */
	void updateCurrentNode(int n) {
		for (int i = 0; i < n; ++i) {
			this.current_nodes.pop();
		}
	}

	/* Call this to reinitialize the node stack. */
	void reset() {
		this.nodes.empty();
		this.current_nodes = new java.util.Stack<Node>();
	}

	/* Return the root node of the AST. */
	Node rootNode() {
		return this.nodes.elementAt(0);
	}

	/* Return the most recently constructed node. */
	Node currentNode() {
		return this.current_nodes.peek();
	}

	/* Push a node on to the stack. */
	void pushNode(Node n) {
		this.nodes.push(n);
	}

	/*
	 * Return the node on the top of the stack, and remove it from the stack.
	 */
	Node popNode() {
		return this.nodes.pop();
	}

	/* Return the node currently on the top of the stack. */
	Node peekNode() {
		return this.nodes.peek();
	}

	/*
	 * An indefinite node has an unspecified number of children. When it is
	 * closed it collects up all nodes that have been pushed since it was begun
	 * and becomes their parent, and then it is pushed on to the stack.
	 */

	void openIndefiniteNode(Node n) {
		this.current_nodes.push(n);
		this.nodes.mark();
	}

	void closeIndefiniteNode() {
		Node n = currentNode();
		n.jjtOpen();
		for (JJTJexParserNodeEnum e = this.nodes.elementsSinceLastMark(); e
				.hasMoreElements();) {
			Node c = (Node) e.nextElement();
			c.jjtSetParent(n);
			n.jjtAddChild(c);
		}
		this.nodes.popToLastMark();
		n.jjtClose();
		this.nodes.push(n);
		this.node_created = true;
	}

	/*
	 * A definite node is constructed from a fixed number of children. That
	 * number of nodes are popped from the stack and made the children of the
	 * definite node. Then the definite node is pushed on to the stack.
	 */

	void openDefiniteNode(Node n) {
		this.current_nodes.push(n);
	}

	void closeDefiniteNode(int num) {
		Node n = currentNode();
		n.jjtOpen();
		for (JJTJexParserNodeEnum e = this.nodes.elementsTop(num); e
				.hasMoreElements();) {
			Node c = (Node) e.nextElement();
			c.jjtSetParent(n);
			n.jjtAddChild(c);
		}
		this.nodes.popTop(num);
		n.jjtClose();
		this.nodes.push(n);
		this.node_created = true;
	}

	/*
	 * A GT (Greater Than) node is constructed if more than the specified number
	 * of nodes have been pushed since it was begun. All those nodes are made
	 * children of the the GT node, which is then pushed on to the stack. If
	 * fewer have been pushed the node is not constructed and they are left on
	 * the stack.
	 */

	void openGTNode(Node n) {
		this.current_nodes.push(n);
		this.nodes.mark();
	}

	void closeGTNode(int num) {
		if (this.nodes.numElementsSinceLastMark() > num) {
			closeIndefiniteNode();
		} else {
			this.nodes.removeLastMark();
			this.node_created = false;
		}
	}
}

final class JJTJexParserNodeStack {
	private Node[] nodeStack;

	private int[] markStack;

	private int nodeSP;

	private int markSP;

	JJTJexParserNodeStack() {
		this.nodeStack = new Node[500];
		this.markStack = new int[500];
		this.nodeSP = 0;
		this.markSP = 0;
	}

	void empty() {
		if (this.nodeSP > 0) {
			while (--this.nodeSP >= 0) {
				this.nodeStack[this.nodeSP] = null;
			}
		}
		this.nodeSP = 0;
		this.markSP = 0;
	}

	Node elementAt(int i) {
		return this.nodeStack[i];
	}

	Node elementFromTop(int i) {
		return this.nodeStack[this.nodeSP - i - 1];
	}

	void push(Node n) {
		if (this.nodeSP == this.nodeStack.length) {
			Node[] ns = new Node[this.nodeStack.length * 2];
			System.arraycopy(this.nodeStack, 0, ns, 0, this.nodeStack.length);
			this.nodeStack = ns;
		}
		this.nodeStack[this.nodeSP++] = n;
	}

	Node pop() {
		Node n = this.nodeStack[--this.nodeSP];
		this.nodeStack[this.nodeSP] = null;
		return n;
	}

	Node peek() {
		return this.nodeStack[this.nodeSP - 1];
	}

	void mark() {
		if (this.markSP == this.markStack.length) {
			int[] ms = new int[this.markStack.length * 2];
			System.arraycopy(this.markStack, 0, ms, 0, this.markStack.length);
			this.markStack = ms;
		}
		this.markStack[this.markSP++] = this.nodeSP;
	}

	void removeLastMark() {
		--this.markSP;
	}

	int numElementsSinceLastMark() {
		return this.nodeSP - this.markStack[this.markSP - 1];
	}

	JJTJexParserNodeEnum elementsSinceLastMark() {
		return new JJTJexParserNodeEnum(this.nodeStack, this.nodeSP,
				this.markStack[this.markSP - 1]);
	}

	void popToLastMark() {
		--this.markSP;
		while (this.nodeSP > this.markStack[this.markSP]) {
			this.nodeStack[--this.nodeSP] = null;
		}
	}

	JJTJexParserNodeEnum elementsTop(int n) {
		return new JJTJexParserNodeEnum(this.nodeStack, this.nodeSP, this.nodeSP - n);
	}

	void popTop(int n) {
		for (int i = 0; i < n; ++i) {
			this.nodeStack[--this.nodeSP] = null;
		}
	}
}

final class JJTJexParserNodeEnum implements java.util.Enumeration<Object> {
	private Node[] nodes;

	private int topSP, index;

	JJTJexParserNodeEnum(Node[] s, int top, int start) {
		this.nodes = s;
		this.topSP = top;
		this.index = start;
	}

	public boolean hasMoreElements() {
		return this.index < this.topSP;
	}

	public Object nextElement() {
		return this.nodes[this.index++];
	}
}

class JJJexParserCalls {
	int gen;

	Token first;

	int arg;

	JJJexParserCalls next;
}
/*
 * $Log: JexParser.java,v $
 * Revision 1.13  2010/12/07 16:36:45  olga
 * bug fixed when a static member of a static class is used in attr expression
 *
 * Revision 1.12  2010/09/23 08:15:01  olga
 * tuning
 *
 * Revision 1.11  2010/03/31 21:10:49  olga
 * tuning
 *
 * Revision 1.10  2010/03/11 13:39:38  olga
 * test
 *
 * Revision 1.9  2010/03/08 15:38:21  olga
 * code optimizing
 *
 * Revision 1.8  2008/01/14 08:46:42  olga
 * Bug fixed in using of CSP without Backjumping (CSP w/o BJ) match algorithm;
 * Bug fixed in using layered graph transformation with loop over layers.
 *
 * Revision 1.7  2007/11/05 09:18:23  olga
 * code tuning
 *
 * Revision 1.6  2007/11/01 09:58:17  olga
 * Code refactoring: generic types- done
 *
 * Revision 1.5  2007/09/10 13:05:48  olga
 * In this update:
 * - package xerces2.5.0 is not used anymore;
 * - class com.objectspace.jgl.Pair is replaced by the agg own generic class agg.util.Pair;
 * - bugs fixed in:  usage of PACs in rules;  match completion;
 * 	usage of static method calls in attr. conditions
 * - graph editing: added some new features
 * Revision 1.4 2007/05/07 07:59:37 olga CSP:
 * extentions of CSP variables concept
 * 
 * Revision 1.3 2007/02/19 09:11:01 olga Bug during loading file fixed. Type
 * editor tuning
 * 
 * Revision 1.2 2006/08/09 07:42:18 olga API docu
 * 
 * Revision 1.1 2005/08/25 11:56:52 enrico *** empty log message ***
 * 
 * Revision 1.2 2005/06/20 13:37:04 olga Up to now the version 1.2.8 will be
 * prepared.
 * 
 * Revision 1.1 2005/05/30 12:58:01 olga Version with Eclipse
 * 
 * Revision 1.5 2005/03/21 10:15:35 olga renamed: enum to en
 * 
 * Revision 1.4 2005/03/21 09:22:57 olga ...
 * 
 * Revision 1.2 2003/03/05 18:24:15 komm sorted/optimized import statements
 * 
 * Revision 1.1.1.1 2002/07/11 12:17:04 olga Imported sources
 * 
 * Revision 1.8 2000/04/05 12:10:53 shultzke serialVersionUID aus V1.0.0
 * generiert
 * 
 * Revision 1.7 2000/03/14 10:59:41 shultzke Transformieren von Variablen auf
 * Variablen sollte jetzt funktionieren Ueber das Design der Copy-Methode des
 * abstrakten Syntaxbaumes sollte unbedingt diskutiert werden.
 * 
 */
